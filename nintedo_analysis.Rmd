---
title: "Nintendo Analysis"
output: pdf_document
---

# Introduction

```{r setup, include=FALSE}
setwd("~/timeseries_finance")
```

```{r load-packages, include=FALSE}

library(tidyverse)
library(dplyr)
library(ggplot2)
library(tseries)          # for ts object, ADF test
library(forecast)         # to predict price
library(zoo)
library(caTools)
library(rugarch)
library(quantmod)
library(rmgarch)


```

# ARIMA Model

```{r load date}

#data <- read.csv('nintendo_daily.csv')

getSymbols("NTDOY", from = '2013-01-01', to = '2021-12-01')
head(NTDOY)

```

## Overview

```{r Overview}
#summary(data)
ts_nintendo <- ts(NTDOY$NTDOY.Close, frequency = 260)
plot(ts_nintendo)

### log transformation
#plot(ts_nintendo_log)
ts_nintendo_log <- log(ts_nintendo)

plot(ts_nintendo_log, main="Stock Price Nintento log transformed 2016-2021")
# https://rpubs.com/kevinTongam/arimaforecast
```

```{r Autocorrelation}
acf_log <- acf(ts_nintendo_log, lag.max = 320)
pacf_log <- pacf(ts_nintendo_log, lag.max = 320)
```

```{r Differencing}
ts_nintendo_diff <- diff(ts_nintendo_log, lag = 1)

# fill missing data with the previous value
ts_nintendo_diff <- na.locf(ts_nintendo_diff,
                            na.rm = TRUE,
                            fromLast = TRUE)
plot(ts_nintendo_diff)
```

```{r Augmented Dickey Fuller Test}
# Additional test to prove stationarity
adf.test(ts_nintendo_log)
```

```{r Additional-Stationary Test}
# Additional test to prove stationarity
adf_diff <- adf.test(ts_nintendo_diff, alternative = c("stationary", "explosive"), 
                k = 0)
adf_diff

``````

```{r Autocorrelation}
# Additional test to prove stationarity
acf_diff <- acf(ts_nintendo_diff)

length(ts_nintendo_diff)


``````

```{r Partical Autorcorrelation}

acf_diff <- pacf(ts_nintendo_diff)


```
```{r Train-data split}
ts_nintendo_diff_train <- ts_nintendo_diff[1:1200]
```

```{r Fitting ARIMA Model}
set.seed(123)
arima_model <- auto.arima(ts_nintendo_diff_train, stationary = TRUE, ic = c("aicc", "aic", "bic"), 
                          trace = TRUE)

checkresiduals(arima_model)
```
## Forecasting

```{r Forecasting}
arima <- arima(ts_nintendo_diff_train, order = c(0,0,1))


forecast_ori <- forecast(arima, h = 100)
a <- ts(ts_nintendo_diff)
forecast_ori %>% autoplot() + autolayer(a)
```

# Univariate GARCH Model

In this chapter we mainly use the functionality of the "rugarch" package, which was written by Alexios Galanos.

## Data preparation

When we are dealing with volatility models, we cannot use "just" the stock prices. We need the returns on a daily/weekly basis.

```{r Data preparation}

return_nintento <- dailyReturn(NTDOY$NTDOY.Close)

chartSeries(return_nintento)

```

## Model preparation

Here we let R know about which GARCH model type we want to estimate. The function `ugarchspec( )` is
used for specifing the GARCH model.

```{r}

ug_spec = ugarchspec()
ug_spec

```

In the ug_spec we already see that the standard model is an ARMA(1,1) model, which is also the outcome of the ARIMA Model before ARIMA(1,0,1) -> ARMA(1,1). That's why we leave the standard model.

## Model estimation

After the model specification for the estimation, we need to find the best parameters.

```{r}
ugfit = ugarchfit(spec = ug_spec, data = return_nintento)

```
Outcome for volatility specification of GARCH:
omega ->  variance intercept parameter
alpha1 -> coefficient to the squared residuals
beta1 ->  coefficient to the lagged variance

Furthermore, `ugfit` contains now all the information of the GARCH model. In this object you can
find two slots, @fit and @model. Each of these contains a range of different parameters, whic hcan be read
out with the `names()` function.

```{r}
names(ugfit@model)
```


## Model Forecasting